import torch

# Define the testing loop
def test_loop(dataloader, model):
    total, correct = 0, 0
    tp, fp, tn, fn = 0, 0, 0, 0
    # Disable weight update
    total = 0
    with torch.no_grad():
        for X,y in dataloader:
            # print(y)
            pred = model(X)
            # print(pred)
            _, prediction_c = torch.max(pred.data, 1)
            # print(prediction_c)
            total += y.size(0)
            correct += (prediction_c == y).sum().item()
            
            for i, ex in enumerate(y):
                if ex == 1:
                    if ex == prediction_c[i]: tp += 1
                    else: fp += 1
                else:
                    if ex == prediction_c[i]: tn += 1
                    else: fn += 1
        print(tp, fp, tn, fn)
        print(f'Accuracy: {100 * correct / total}')


if __name__ == "__main__":
    import torch
    from utils.load_dataset import load_test_dataset
    from load_model import load_model
    
    test_dataloader = load_test_dataset()
    # Model initialization
    model = load_model('model_new_dataset.pth')

    # How many times our model analyzes the dataset
    epochs = 3

    print("[+] Testing the model")
    # Train the model
    for t in range(epochs):
        print(f'Epoch: {t}')
        test_loop(test_dataloader, model)
        